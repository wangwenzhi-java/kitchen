spring:
  ####### database Config #######
  datasource:
    druid:
      # 设置数据库连接的初始化 SQL 语句
      connection-init-sqls: set names utf8mb4  # 确保数据库使用 utf8mb4 字符集
      # JDBC 驱动类名
      driver-class-name: com.mysql.cj.jdbc.Driver  # 使用 MySQL 的 JDBC 驱动
      # 启用闲置连接检查
      test-while-idle: true  # 检查闲置连接是否有效
      # 获取连接时验证
      test-on-borrow: true  # 在从连接池获取连接时进行验证
      # 归还连接时验证
      test-on-return: true  # 在将连接归还给连接池时进行验证
      # 校验查询，测试连接有效性
      validation-query: SELECT 1  # 测试查询，检查连接是否有效
      # 设置连接验证查询的超时时间（单位：秒）
      validation-query-timeout: 5  # 设置验证查询的最大执行时间为 5 秒
      # 启用移除长时间未使用的连接
      remove-abandoned: true  # 启用丢弃长时间未使用的连接
      # 丢弃连接的超时设置（单位：秒）
      remove-abandoned-timeout: 60  # 60 秒内没有使用的连接将被丢弃
      # 设置连接池最大等待时间（单位：毫秒）
      max-wait: 30000  # 最大等待时间 30 秒
      # 设置最小闲置连接数
      min-idle: 5  # 最小闲置连接数
      # 设置最大活跃连接数
      max-active: 20  # 最大活跃连接数
      # 设置连接池初始化连接数
      initial-size: 5  # 初始化连接数
      # 设置最大打开的 PreparedStatement 数量
      max-open-prepared-statements: 20  # 最大 PreparedStatement 数量
      # 设置连接池中的最小空闲时间（单位：毫秒），超过该时间的连接将被移除
      min-evictable-idle-time-millis: 600000  # 10 分钟，超过空闲 10 分钟的连接将被清理
      # 设置空闲连接检查周期（单位：毫秒）
      time-between-eviction-runs-millis: 300000  # 每 5 分钟检查一次空闲连接
      # 数据源类型
      type: com.alibaba.druid.pool.DruidDataSource  # 使用 Druid 数据源

    #测试：url: jdbc:mysql://${KITCHEN_DATASOURCE_HOST:127.0.0.1}:${KITCHEN_DATASOURCE_PORT:3306}/${KITCHEN_DATASOURCE_DATABASE_NAME:dblog}?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&autoReconnect=true&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&useSSL=false&allowPublicKeyRetrieval=true&useLegacyDatetimeCode=false
    #线上↓
    url: jdbc:mysql://${KITCHEN_DATASOURCE_HOST:127.0.0.1}:${KITCHEN_DATASOURCE_PORT:3306}/${KITCHEN_DATASOURCE_DATABASE_NAME:kitchen}?serverTimezone=Asia/Shanghai&useUnicode=true&characterEncoding=utf-8&autoReconnect=true&zeroDateTimeBehavior=convertToNull&allowMultiQueries=true&useSSL=false&allowPublicKeyRetrieval=true&useLegacyDatetimeCode=false
    username: ${KITCHEN_DATASOURCE_USERNAME:KITCHEN} #你的用户名
    password: ${KITCHEN_DATASOURCE_PASSWORD:KITCHEN} #你的密码

  ####### Redis Config 注意！！！springboot3的redis前缀是spring.data.redis!!springboot2.x的redis配置是spring.redis 别踩坑！！#######
  data:
    redis:
      host: 127.0.0.1  # Redis 主节点的 IP 地址
      port: 6379  # Redis 主节点的端口，默认为 6379
      password: 123  # Redis 密码（如果有的话）
      database: 2  # 选择数据库的索引，默认为 0
      lettuce:
        pool:
          # 连接池最大连接数(使用负值表示没有限制) 默认为8
          max-active: 8
          # 连接池中的最大空闲连接 默认为8
          max-idle: 8
          # 连接池最大阻塞等待时间(使用负值表示没有限制) 默认为-1
          max-wait: -1
          # 连接池中的最小空闲连接 默认为 0
          min-idle: 0
  ####### redis缓存服务配置 #######
  session:
    store-type: redis
  #rabbitMq配置
  rabbitmq:
    host: 127.0.0.1
    port: 5672
    username: guest #你的
    password: guest #你的
  # 指定默认MimeMessage的编码，默认为: UTF-8
  mail:
    default-encoding: UTF-8
    # 指定SMTP server使用的协议，默认为: smtp
    protocol: smtp
    # 指定SMTP server host.
    host: ${KITCHEN_MAIL_HOST:x}
    port: ${KITCHEN_MAIL_PORT:465}
    # 指定SMTP server的用户名.
    username: ${KITCHEN_MAIL_USERNAME:x}
    # 指定SMTP server登录密码:
    password: ${KITCHENG_MAIL_PASSWORD:x}
    # 指定是否在启动时测试邮件服务器连接，默认为false
    test-connection: false
    properties:
      mail.smtp.auth: true
      # 腾讯企业邮箱 下两个配置必须！！！
      mail.smtp.ssl.enable: true
      mail.smtp.socketFactory.class: javax.net.ssl.SSLSocketFactory
      mail.smtp.socketFactory.port: 465
      mail.smtp.starttls.enable: true
      mail.smtp.starttls.required: true
      mail.smtp.connectiontimeout: 50000
      mail.smtp.timeout: 30000
      mail.smtp.writetimeout: 50000
  application:
    name: ${KITCHEN_APPLICATION_NAME:kitchen}
# pagehelper
pagehelper:
  helper-dialect: mysql
  reasonable: true
  support-methods-arguments: true
  params: count=countSql

app:
  version: ${KITCHEN_APP_VERSION:v1.0.0}
  enableRedisCache: ${KITCHEN_ENABLE_REDIS_CACHE:false}
    # 配置 RabbitMQ 交换机和队列的绑定
    bindings:
      friendRequest-out:
        producer:
          exchange: chat_direct_exchange  # 显式指定交换机名称
          routingKey: friendRequest  # 设置路由键
          exchangeType: direct  # 设置交换机类型

      friendMessage-out:
        producer:
          exchange: chat_direct_exchange  # 显式指定交换机名称
          routingKey: friendMessage  # 设置路由键
          exchangeType: direct  # 设置交换机类型

      logSave-out:
        producer:
          exchange: log_direct_exchange  # 显式指定交换机名称
          routingKey: logSave  # 设置路由键
          exchangeType: direct  # 设置交换机类型






          bindings:
            # 生产者绑定: friend_request_queue
            friendRequest-out:
              destination: friend_request_queue  # 目标队列名称
              binder: rabbit  # 使用 RabbitMQ 作为消息中间件
              producer:

                routingKey: friendRequest  # 路由键
                exchangeType: direct  # 交换机类型为 direct
                exchange: chat_direct_exchange  # 显式指定交换机名称

            # 生产者绑定: friend_message_queue
            friendMessage-out:
              destination: friend_message_queue  # 目标队列名称
              binder: rabbit
              producer:
                routingKey: friendMessage  # 路由键
                exchangeType: direct  # 交换机类型为 direct
                exchange: chat_direct_exchange  # 显式指定交换机名称

            # 生产者绑定: log_save_queue
            logSave-out:
              destination: log_save_queue  # 目标队列名称
              binder: rabbit
              producer:
                routingKey: logSave  # 路由键
                exchangeType: direct  # 交换机类型为 direct
                exchange: log_direct_exchange  # 显式指定交换机名称

            # 消费者绑定: friend_request_queue
            friendRequest-in:
              destination: friend_request_queue  # 目标队列名称
              binder: rabbit  # 使用 RabbitMQ 作为消息中间件
              consumer:
                group: friendRequestGroup  # 消费者组
                concurrency: 3  # 设置消费者并发数
                max-concurrency: 10  # 设置最大并发数
                ackMode: manual  # 手动确认模式
                exchange: chat_direct_exchange  # 显式指定交换机名称
                routingKey: friendRequest  # 设置路由键
                exchangeType: direct  # 设置交换机类型

            # 消费者绑定: friend_message_queue
            friendMessage-in:
              destination: friend_message_queue  # 目标队列名称
              binder: rabbit
              consumer:

                group: friendMessageGroup  # 消费者组
                concurrency: 3  # 设置消费者并发数
                max-concurrency: 10  # 设置最大并发数
                ackMode: manual  # 手动确认模式
                exchange: chat_direct_exchange  # 显式指定交换机名称
                routingKey: friendMessage  # 设置路由键
                exchangeType: direct  # 设置交换机类型

            # 消费者绑定: log_save_queue
            logSave-in:
              destination: log_save_queue  # 目标队列名称
              binder: rabbit
              consumer:
                group: logSaveGroup  # 消费者组
                concurrency: 3  # 设置消费者并发数
                max-concurrency: 10  # 设置最大并发数
                ackMode: manual  # 手动确认模式
                exchange: log_direct_exchange  # 显式指定交换机名称
                routingKey: logSave  # 设置路由键
                exchangeType: direct  # 设置交换机类型

                # RabbitMQ Binder 配置
                rabbit:
                  binder:
                    type: rabbit  # 使用 RabbitMQ 作为消息中间件

                  connection:
                    host: ${KITCHEN_RABBITMQ_HOST:120.46.8.55}  # RabbitMQ 主机
                    port: ${KITCHEN_RABBITMQ_PORT:5672}  # RabbitMQ 端口
                    username: ${KITCHEN_RABBITMQ_USERNAME:chatMq}  # RabbitMQ 用户名
                    password: ${KITCHEN_RABBITMQ_PASSWORD:chatMq}  # RabbitMQ 密码
                    virtual-host: ${KITCHEN_RABBITMQ_VIRTUAL_HOST:chat}  # 虚拟主机
                    publisher-confirm-type: correlated  # 启用生产者确认机制
                    publisher-returns: true  # 启用消息返回功能

                  listener:
                    simple:
                      auto-declare: true  # 启用自动声明
                      concurrency: 3  # 设置消费者并发数
                      max-concurrency: 10  # 设置最大并发数
                      x-queue-mode: lazy  # 使用懒加载模式，减少内存占用
                      x-durable: true  # 队列持久化（必须设置）
                      # x-message-ttl: 60000  # 设置消息过期时间（可根据需求启用）